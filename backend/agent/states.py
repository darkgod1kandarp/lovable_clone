from pydantic import BaseModel, Field, ConfigDict
from typing import Annotated, TypedDict
from langgraph.graph.message import add_messages
from langchain_core.messages import BaseMessage  

from typing import Optional

class File(BaseModel): 
    path: str = Field(..., description="The path of the file to be created, e.g. 'src/index.html'")   
    purpose: str = Field(..., description="The purpose of the file, e.g. 'main application logic', 'data processing module', 'styling'")

class Plan(BaseModel):  
    name: str = Field(..., description="The name of the app to be built")  
    description: str = Field(..., description="A oneline description of the app to be built, e.g. 'A web  application for managing tasks'")
    techstack: list[str] = Field(..., description="A list of technologies to be used for building the app, e.g. ['React', 'Node.js', 'MongoDB']")   
    features: list[str] = Field(..., description="A list of features to be implemented in the app, e.g. ['User authentication', 'Task management', 'Notifications']")     
    files: list[File] = Field(..., description="A list of files to be created, each with a path and a purpose")  
    
class ImplementationTask(BaseModel):  
    filepath: str = Field(..., description="The file where the task needs to be implemented or modified, e.g. 'src/index.html'")   
    task_description: str = Field(..., description="A detailed description of what needs to be implemented in the specified file, including variable names, function names, class names, dependencies on previous tasks, and integration details such as import statements and function calls.")
    
class TaskPlan(BaseModel):  
    implementation_steps: list[ImplementationTask] = Field(..., description="A list of implementation tasks, each specifying the file to be modified and a detailed description of the implementation work to be done in that file.")
    model_config = ConfigDict(extra="allow") 
    
class CoderState(BaseModel):   
    task:TaskPlan = Field(..., description="The task plan generated by the architect agent, containing a list of implementation tasks with details on what needs to be implemented in each file.")   
    current_step_idx: int = Field(0, description="The index of the current implementation step being processed.")    
    current_file_content: str = Field("", description="The existing content of the file being modified in the current implementation step, which can be used for reference while generating code.")
    
class ResolverState(BaseModel): 
    task: ImplementationTask = Field(..., description="The implementation task that is currently being worked on by the coder agent, which may have encountered errors during code generation.")
    error_message: str = Field(..., description="The error message generated from the failed code execution, which will be analyzed by the resolver agent to identify and fix the issue in the code.")
    resolved: bool = Field(False, description="A flag indicating whether the error has been successfully resolved by the resolver agent. Initially set to False and updated to True once the issue is fixed.")
    
class AgentState(TypedDict, total=False):
    messages: Annotated[list[BaseMessage], add_messages] # Keeps chat history
    project_id: str
    plan: Plan | None
    task_plan: TaskPlan | None
    coder_state: CoderState | None
    llm: any  # This will hold the LLM instance to be passed between agents for continuity
    status: Optional[str]        # truly optional, defaults to key-not-present
    error_message: Optional[str] # same

